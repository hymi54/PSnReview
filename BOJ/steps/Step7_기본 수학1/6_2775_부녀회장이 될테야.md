## 조건
- 시간 제한 : 1초
- 입력값 <= 14, 14   
  -> O(2^n)까지도 괜찮을 듯? : 재귀로 풀어도 될듯?   
  -> 그래도 수학적으로 풀어보자
  -> 실패...

## 첫 번째 풀이
```python
def kn(k: int, n: int) -> int:
    if k == 0:
        return n
    elif n == 1:
        return 1
    else:
        return kn(k-1, n) + kn(k, n-1)


for _ in range(int(input())):
    k = int(input())
    n = int(input())
    print(kn(k, n))
```

### 풀이 과정
1. 앞 호수의 사람 수 + 아래층 호수의 사람 수 = 현재 호의 사람 수
2. 아래층 호수의 사람 수는 앞 호수의 모든 층 사람 수를 더한 것과 같다.
3. 2번으로 풀어도 결국 앞 사람 수를 구해야 되므로 재귀 밖에 답이 없을 것 같다.

### 결과 & 문제점
- 시간 초과
- 분명 1억번 보다는 연산 횟수가 적을텐데...

### 해결
- python3 대신 Pypy3으로 제출하니 성공! python3이 좀 더 느리다고 한다.
- pypy3은 python3에 JIT 컴파일을 적용한 것인데, 쉽게 말해서 자주 쓰이는 코드를 캐싱하는 기능이 있어 반복이 많은 코드에서 더 효율적이라고 한다.
- 단, 이는 메모리를 더 사용해서 저장한다는 것이므로 속도와 메모리 상황에 맞춰 잘 선택해야 할 것이다.
> 추가로 DP를 사용해 푸는 방법도 있다고 한다!